security.h 的設計邏輯
統一的安全門戶：
將 AES (保密性) 與 CRC (完整性) 放在同一個標頭檔，是因為在工業協議中，這兩者通常是「打包處理」的。數據必須先校驗沒壞（CRC），再解密讀取內容（AES）。
區塊對齊規範 (Block Alignment)：
定義 #define AES_BLOCK_SIZE 16。這是在提醒其他開發者：如果你要傳輸的 Packet_t 長度不是 16 的倍數，必須進行 Padding (填充)。這是開發嵌入式通訊協定時最常出錯的地方。
無狀態設計 (Stateless)：
函式設計為 aes_encrypt(input, output, len, key)。這種設計不依賴全域變數，方便你在 server.c 的 Multi-thread (Worker process) 環境中並行呼叫，不會產生競態條件 (Race Condition)。

AES.c 的實作邏輯
對稱加密的優勢：
AES 是對稱金鑰演算法。對於工廠端的感測器（Client）和中控伺服器（Server）來說，計算壓力遠小於 RSA 等非對稱加密。這能確保感測器不會因為加密而導致數據傳輸延遲（Latency），這對計算 Cycle Time (生產節拍) 至關重要。
S-Box 與輪運算 (Rounds)：
AES.c 內部的 SubBytes、ShiftRows 等步驟是為了將數據「徹底攪碎」。即使駭客攔截到無線訊號，也無法從亂碼中推斷出機臺現在是正在運作還是停機。
處理數據對齊 (Handling Alignment)：
在實作中，當 Packet_t 長度不等於 16 倍數的情況（例如 Protocol 可能是 42 bytes）。AES.c 內的設計邏輯會自動補零或根據 PKCS7 標準填充，確保加密過程不會崩潰。

使用AES的原因:
1. 保護「生產 Know-how」(防止工業間諜)
風險：如果數據明文傳輸，競爭對手只要在工廠外監聽 Wi-Fi/LoRa 訊號，就能精確分析出產能、良率、甚至訂單量。
AES 的作用：確保這些反映工廠核心競爭力的數據，只有中控室的 server.c 能解讀。
2. 防止「數據篡改」(防止錯誤決策)
系統會根據統計分析給予 「調整機臺產數」 的建議。
風險：如果沒有加密與校驗，惡意攻擊者可以注入偽造的「震動數據」或「低稼動率報告」。
後果：系統會給出錯誤的「生產線平衡建議」，導致管理層撤掉原本正常的機臺，造成真實的生產損失。
AES 的作用：結合密鑰驗證，確保數據來源是真實的感測器，而非外部偽造。
3. 統計分析的「乾淨數據」需求
libstats.so 依賴精確的數值來跑 Poisson 分配 或 SPC 控制圖。
AES + CRC 的協作：
CRC 負責過濾掉「物理環境干擾」（如電磁雜訊導致的位元錯誤）。
AES 負責過濾掉「人為惡意干擾」。
